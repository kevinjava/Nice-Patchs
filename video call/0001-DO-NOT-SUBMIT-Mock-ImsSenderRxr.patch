From a2b42acfb5702f504088a6f74490cc7958798780 Mon Sep 17 00:00:00 2001
From: Imazeki Koichiro <koichiro.x.imazeki@sonymobile.com>
Date: Mon, 29 Sep 2014 14:55:00 +0900
Subject: [PATCH 1/2] DO NOT SUBMIT : Mock ImsSenderRxr

Provides Mock ImsSenderRxr to simulate telephony IMS functions.

Change-Id: I8ea6834c92ccdd3e3eb25107e598c00bcfb2a5d7
(cherry picked from commit aad1bceb5ad0ee2ae2226c4e8bb7f175541abf84)
---
 ims/src/org/codeaurora/ims/ImsSenderRxr.java       |    8 +-
 .../org/codeaurora/ims/ImsServiceClassTracker.java |   28 +
 ims/src/org/codeaurora/ims/ImsServiceSub.java      |   11 +-
 ims/src/org/codeaurora/ims/MockImsSenderRxr.java   | 1730 ++++++++++++++++++++
 4 files changed, 1772 insertions(+), 5 deletions(-)
 create mode 100644 ims/src/org/codeaurora/ims/MockImsSenderRxr.java

diff --git a/ims/src/org/codeaurora/ims/ImsSenderRxr.java b/ims/src/org/codeaurora/ims/ImsSenderRxr.java
index a6a8773..254ed72 100644
--- a/ims/src/org/codeaurora/ims/ImsSenderRxr.java
+++ b/ims/src/org/codeaurora/ims/ImsSenderRxr.java
@@ -209,7 +209,7 @@ class IFRequest {
 /**
  * IMS implementation of the CommandsInterface. {@hide}
  */
-public final class ImsSenderRxr extends ImsPhoneBaseCommands implements ImsPhoneCommandsInterface {
+public class ImsSenderRxr extends ImsPhoneBaseCommands implements ImsPhoneCommandsInterface {
     static final String LOG_TAG = "ImsSenderRxr";
     static final boolean IF_LOGD = true;
     static final boolean IF_LOGV = true; // STOP SHIP if true
@@ -298,7 +298,7 @@ public final class ImsSenderRxr extends ImsPhoneBaseCommands implements ImsPhone
 
     private RegistrantList mHandoverStatusRegistrants = new RegistrantList();
     private RegistrantList mRefreshConfInfoRegistrations = new RegistrantList();
-    private RegistrantList mSrvStatusRegistrations = new RegistrantList();
+    protected RegistrantList mSrvStatusRegistrations = new RegistrantList();
     private RegistrantList mTtyStatusRegistrants = new RegistrantList();
     private RegistrantList mRadioStateRegistrations = new RegistrantList();
     private RegistrantList mGeolocationRegistrants = new RegistrantList();
@@ -1199,7 +1199,7 @@ public final class ImsSenderRxr extends ImsPhoneBaseCommands implements ImsPhone
         rr.release();
     }
 
-    private String retToString(int req, Object ret) {
+    protected String retToString(int req, Object ret) {
 
         if (ret == null)
             return "";
@@ -2875,7 +2875,7 @@ public final class ImsSenderRxr extends ImsPhoneBaseCommands implements ImsPhone
         return response;
     }
 
-    private int getImsReasonForCallFailCause(ImsQmiIF.CallFailCauseResponse failCauseResp) {
+    protected int getImsReasonForCallFailCause(ImsQmiIF.CallFailCauseResponse failCauseResp) {
         int failCause = failCauseResp.getFailcause();
         int imsCode = ImsReasonInfo.CODE_UNSPECIFIED;
         log("Call fail cause= " + failCause);
diff --git a/ims/src/org/codeaurora/ims/ImsServiceClassTracker.java b/ims/src/org/codeaurora/ims/ImsServiceClassTracker.java
index b4c1cca..b4823e4 100644
--- a/ims/src/org/codeaurora/ims/ImsServiceClassTracker.java
+++ b/ims/src/org/codeaurora/ims/ImsServiceClassTracker.java
@@ -6,6 +6,8 @@
 
 package org.codeaurora.ims;
 
+import org.codeaurora.ims.MockImsSenderRxr;
+
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
@@ -623,6 +625,32 @@ public class ImsServiceClassTracker implements ImsCallSessionImpl.Listener{
      * @param info
      */
     public void handleSuppSvcUnsol(ImsQmiIF.SuppSvcNotification info) {
+        if (mCi instanceof MockImsSenderRxr) {
+            synchronized (mCallList) {
+                List<ImsCallSessionImpl> sessionList =
+                        getCallSessionByState(DriverCallIms.State.ACTIVE);
+                ImsCallSessionImpl callSession =
+                        sessionList.isEmpty() ? null : sessionList.get(0);
+                if (callSession != null) {
+                    ImsSuppServiceNotification mockSuppServiceInfo =
+                            new ImsSuppServiceNotification();
+                    mockSuppServiceInfo.notificationType =
+                            ((MockImsSenderRxr) mCi).getSsNotificationType();
+                    mockSuppServiceInfo.code = ((MockImsSenderRxr) mCi).getSsCode();
+                    mockSuppServiceInfo.index = ((MockImsSenderRxr) mCi).getSsIndex();
+                    mockSuppServiceInfo.number = ((MockImsSenderRxr) mCi).getSsNumber();
+                    boolean startOnHoldLocalTone = false;
+                    if (info != null && info.hasHoldTone()) {
+                        startOnHoldLocalTone = info.getHoldTone();
+                    }
+                    Log.d(LOG_TAG, "handleSuppSvcUnsol suppNotification= " + mockSuppServiceInfo +
+                            " startOnHoldLocalTone = " + startOnHoldLocalTone);
+                    callSession.updateSuppServiceInfo(mockSuppServiceInfo, startOnHoldLocalTone);
+                }
+            }
+            return;
+        }
+
         Log.d(LOG_TAG, "handleSuppSvcUnsol connId= " + info.getConnId());
         synchronized (mCallList) {
             ImsCallSessionImpl callSession =
diff --git a/ims/src/org/codeaurora/ims/ImsServiceSub.java b/ims/src/org/codeaurora/ims/ImsServiceSub.java
index ee3953e..c9c1a5a 100644
--- a/ims/src/org/codeaurora/ims/ImsServiceSub.java
+++ b/ims/src/org/codeaurora/ims/ImsServiceSub.java
@@ -57,6 +57,7 @@ import android.os.Looper;
 import android.os.RegistrantList;
 import android.os.RemoteException;
 import android.telephony.TelephonyManager;
+import android.os.SystemProperties;
 
 public class ImsServiceSub {
     private static final String LOG_TAG = "ImsServiceSub";
@@ -155,7 +156,15 @@ public class ImsServiceSub {
     public ImsServiceSub(int sub, Context context) {
         mSub = sub;
         mContext = context;
-        mCi = new ImsSenderRxr(mContext);
+        boolean isMockDisabled =
+                SystemProperties.getBoolean("persist.telephony.mockdisabled", false);
+        if (isMockDisabled) {
+            Log.i(LOG_TAG, "MockImsSenderRxr : Disabled");
+            mCi = new ImsSenderRxr(mContext);
+        } else {
+            Log.i(LOG_TAG, "MockImsSenderRxr : Enabled");
+            mCi = new MockImsSenderRxr(mContext);
+        }
         mHandler = new ImsServiceSubHandler();
 
         mRegHandlerThread = new HandlerThread(LOG_TAG + "RegHandlerThread");
diff --git a/ims/src/org/codeaurora/ims/MockImsSenderRxr.java b/ims/src/org/codeaurora/ims/MockImsSenderRxr.java
new file mode 100644
index 0000000..3b75d23
--- /dev/null
+++ b/ims/src/org/codeaurora/ims/MockImsSenderRxr.java
@@ -0,0 +1,1730 @@
+/*
+ * MockImsSenderRxr
+ */
+
+package org.codeaurora.ims;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.os.AsyncResult;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.Looper;
+import android.os.Message;
+import android.os.Parcel;
+import android.os.SystemProperties;
+import android.telephony.TelephonyManager;
+import android.text.TextUtils;
+import android.telephony.PhoneNumberUtils;
+import android.util.Log;
+import android.widget.Toast;
+
+import com.android.ims.ImsReasonInfo;
+import com.android.internal.telephony.CallForwardInfo;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.concurrent.CountDownLatch;
+import java.util.Timer;
+import java.util.TimerTask;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class MockImsSenderRxr extends ImsSenderRxr {
+    static final String LOG_TAG = "MockImsSenderRxr";
+
+    // Intents for Test commands
+    private static final String ACTION_IMS_STATE_CHANGED =
+            "com.telephony.mockims.intent.action.IMS_STATE_CHANGED";
+
+    private static final String ACTION_CALL_STATE_CHANGED =
+            "com.telephony.mockims.intent.action.CALL_STATE_CHANGED";
+
+    private static final String ACTION_DOWNGRADE_UPGRADE =
+            "com.telephony.mockims.intent.action.ACTION_DOWNGRADE_UPGRADE";
+
+    private static final String ACTION_VIDEO_SHARE =
+            "com.telephony.mockims.intent.action.VIDEO_SHARE";
+
+    private static final String ACTION_REJECT_DOWNGRADE_UPGRADE =
+            "com.telephony.mockims.intent.action.ACTION_REJECT_DOWNGRADE_UPGRADE";
+
+    private static final String ACTION_DELAY_RESPONSE =
+            "com.telephony.mockims.intent.action.ACTION_DELAY_RESPONSE";
+
+    private static final String ACTION_NW_SERVICE_ERROR_MODE_CHANGED =
+            "com.telephony.mockims.intent.action.ACTION_NW_SERVICE_ERROR_MODE_CHANGED";
+
+    private static final String ACTION_SUPP_SERVICE_NOTIFICATION =
+            "com.telephony.mockims.intent.action.SUPP_SERVICE_NOTIFICATION";
+
+    private static final String ACTION_REQ_ERROR_MODE_CHANGED =
+            "com.telephony.mockims.intent.action.ACTION_REQ_ERROR_MODE_CHANGED";
+
+    // Extra data
+    private static final String EXTRA_IMS_REG_STATE = "imsregstate";
+    private static final String EXTRA_CALL_COMMAND = "callcommand";
+    private static final String EXTRA_CALL_FAIL_CODE = "failcode";
+    private static final String EXTRA_CALL_INCOMING_NUMBER = "incomingnumber";
+    private static final String EXTRA_CALL_INCOMING_TYPE = "incomingtype";
+    private static final String EXTRA_CALL_NUMBER_PRESENTATION = "numpresentation";
+    private static final String EXTRA_CALL_INCOMING_NAME = "incomingname";
+    private static final String EXTRA_CALL_NAME_PRESENTATION = "namepresentation";
+
+    private static final String EXTRA_VOICE_CODEC = "voicecodec";
+    private static final String EXTRA_DELAY = "delay";
+    private static final String EXTRA_ERROR_MODE = "error_mode";
+
+    private static final String EXTRA_SIM_ID = "simid";
+
+    private static final String EXTRA_SUPP_NOTIFICATION_TYPE = "supptype";
+    private static final String EXTRA_SUPP_CODE = "suppcode";
+
+    // CALL commands
+    private static final String CALL_COMMAND_ACCEPT_OR_INCOMING = "ACCEPT_OR_INCOMING";
+    private static final String CALL_COMMAND_ENDCALL = "ENDCALL";
+    private static final String CALL_COMMAND_STATE_CHANGE = "STATE_CHANGE";
+
+    private static final String TYPE_VOICE = "voice";
+    private static final String TYPE_VT = "vt";
+
+    // REQUEST ERROR Mode
+    private static final String EXTRA_REQ_ERROR_MODE = "req_error_mode";
+    private static final String EXTRA_REQ_FOR_ERROR = "req_for_error";
+    private static final String EXTRA_REQ_ERROR_TYPE_EXCEPTION = "error_type_exception";
+
+    // Events
+    private static final int EVENT_SEND_SOL_RESPONSE = 100;
+    private static final int EVENT_SEND_UNSOL_RESPONSE = 101;
+
+    private static final int MAX_CALL_COUNTS = 12;
+    private static final int CF_REASON_COUNTS = 6;
+
+    // For Conference
+    private static final int STATE_CONF_ACTIVE_HOLDING = 0;
+    private static final int STATE_CONF_HOLDING_HOLDING = 1;
+    private static final int STATE_CONF_HOLDING_HOLDING_DIALING = 2;
+    private static final int STATE_CONF_HOLDING_HOLDING_ACTIVE = 3;
+    private static final int STATE_CONF_END_HOLDING_ACTIVE = 4;
+    private static final int STATE_CONF_END_ACTIVE = 5;
+    private static final int STATE_CONF_ACTIVE = 6;
+
+    private TelephonyManager mTelMgr;
+    private Timer mTimer = new Timer();
+    private HandlerThread mSenderThread;
+    private MockIFMsg_Sender mSender;
+
+    private boolean mIsModifyCallRequested;
+    private CallModify mCallModify = new CallModify();
+    private CountDownLatch mCountDownLatch;
+    private boolean mIsVideoShareRequest;
+    private boolean mModifyCallRejected;
+
+    private int mResponseDelayMillis = 0;
+    private boolean mErrorMode;
+
+    // For Request Error mode
+    private RequestErrorMode mErrorModeDial = new RequestErrorMode();
+    private RequestErrorMode mErrorModeAnswer = new RequestErrorMode();
+    private RequestErrorMode mErrorModeHangup = new RequestErrorMode();
+    private RequestErrorMode mErrorModeSwitch = new RequestErrorMode();
+    private RequestErrorMode mErrorModeHold = new RequestErrorMode();
+    private RequestErrorMode mErrorModeResume = new RequestErrorMode();
+    private RequestErrorMode mErrorModeConference = new RequestErrorMode();
+    private RequestErrorMode mErrorModeHangupWaiting = new RequestErrorMode();
+    private RequestErrorMode mErrorModeHangupForeResumeBack = new RequestErrorMode();
+
+    private class RequestErrorMode {
+        public boolean mMode;
+        public boolean mIsException;
+    }
+
+    // REQUEST_IMS_REGISTRATION_STATE
+    private int mImsRegState = 2;  // 1: Registered / 2: Not Registered
+
+    // REQUEST_SET_CALL_WAITING / REQUEST_QUERY_CALL_WAITING
+    private boolean mCallWaiting;
+
+    // REQUEST_SET_CALL_FORWARD_STATUS / REQUEST_QUERY_CALL_FORWARD_STATUS
+    private CallForwardInfo[] mCallForwardInfo = new CallForwardInfo[CF_REASON_COUNTS];
+    private int mQueryCfReason = 0;
+
+    // REQUEST_GET_CURRENT_CALLS
+    private int mNumOfCalls = 0;
+    private ImsCall[] mCalls = new ImsCall[MAX_CALL_COUNTS];
+
+    private class ImsCall {
+        public boolean mIsActive;
+
+        // From DriverCallIms
+        public int mIndex;
+        public boolean mIsMT;
+        public DriverCallIms.State mState = null;
+        public boolean mIsMpty;
+        public String mNumber;
+
+        public int mTOA = 129;
+        public boolean mIsVoice = true;
+        public boolean mIsVoicePrivacy;
+        public int mAls = 0;
+        public int mNumberPresentation = 0;
+        public String mName;
+        public int mNamePresentation = 0;
+
+        // Fail Cause
+        public ImsQmiIF.CallFailCauseResponse mFailCode = new ImsQmiIF.CallFailCauseResponse();
+        public String mFailCauseExtraMsg;
+
+        // From CallDetails
+        public int mCall_type = CallDetails.CALL_TYPE_VOICE;
+        public int mCall_domain = CallDetails.CALL_DOMAIN_PS;
+        public String[] mExtras = new String[] {"Codec=AMR_WB"};
+        private int mVideoPauseState = CallDetails.VIDEO_PAUSE_STATE_RESUMED;
+        public ServiceStatus[] mLocalAbility;
+        public ServiceStatus[] mPeerAbility;
+        public int mCallMediaId;
+    }
+
+    // SS Notification
+    private int mSsNotificationType = 0;
+    private int mSsCode = 0;
+    private int mSsIndex = 0;        // not used currently
+    private String mSsNumber = "";   // not used currently
+
+    // For Conference
+    private int mConferenceState = -1;
+    private HandlerThread mConfThread;
+    private ConferenceSender mConfSender;
+    private boolean mIsRequestConference;
+    private IFRequest mConfRequest;
+
+    private Integer mInstanceId = 0;
+
+    // For Ringback Tone
+    private static final boolean RINGBACK_TONE_SUPPORTED =
+            SystemProperties.getBoolean("persist.telephony.rbtsupported", false);
+    private boolean mPlayTone;
+
+
+    /*
+     * Handles test commands.
+     */
+    private BroadcastReceiver mTestCommandReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            String simId = intent.getStringExtra(EXTRA_SIM_ID);
+            if (TextUtils.isEmpty(simId)) {
+                simId = "0";
+            }
+            if (mInstanceId.intValue() != Integer.parseInt(simId)) {
+                log("Command has been ignored. Instance ID:" + mInstanceId.intValue()
+                        + " SIM ID:" + simId);
+                return;
+            }
+
+            if (intent.getAction().equals(ACTION_IMS_STATE_CHANGED)) {
+                processImsStateChanged(context, intent);
+            } else if (intent.getAction().equals(ACTION_CALL_STATE_CHANGED)) {
+                processCallStateChanged(intent);
+            } else if (intent.getAction().equals(ACTION_DOWNGRADE_UPGRADE)) {
+                processDowngradeUpgrade(false, false);
+            } else if (intent.getAction().equals(ACTION_VIDEO_SHARE)) {
+                processDowngradeUpgrade(false, true);
+            } else if (intent.getAction().equals(ACTION_REJECT_DOWNGRADE_UPGRADE)) {
+                processDowngradeUpgrade(true, false);
+            } else if (intent.getAction().equals(ACTION_DELAY_RESPONSE)) {
+                processDelayResponse(context, intent);
+            } else if (intent.getAction().equals(ACTION_NW_SERVICE_ERROR_MODE_CHANGED)) {
+                processNetworkServiceErrorMode(context, intent);
+            } else if (intent.getAction().equals(ACTION_SUPP_SERVICE_NOTIFICATION)) {
+                processSuppSrvNotification(intent);
+            } else if (intent.getAction().equals(ACTION_REQ_ERROR_MODE_CHANGED)) {
+                processRequestErrorMode(context, intent);
+            }
+        }
+    };
+
+    @Override
+    public void registerForPhoneId(int phoneId) {
+        mInstanceId = phoneId;
+        super.registerForPhoneId(phoneId);
+    }
+
+    class ConferenceSender extends Handler implements Runnable {
+        public ConferenceSender(Looper looper) {
+            super(looper);
+        }
+
+        // ***** Runnable implementation
+        public void
+                run() {
+            // setup if needed
+        }
+
+        // ***** Handler implementation
+        @Override
+        public void handleMessage(Message msg) {
+            try {
+                Thread.sleep(100);
+            } catch (InterruptedException e) {
+                // do nothing.
+            }
+
+            switch (msg.what) {
+            case STATE_CONF_ACTIVE_HOLDING:
+                log("STATE_CONF_ACTIVE_HOLDING");
+                for (int i = 0; i < MAX_CALL_COUNTS; i++) {
+                    if (mCalls[i].mState == DriverCallIms.State.ACTIVE) {
+                        mCalls[i].mState = DriverCallIms.State.HOLDING;
+                        break;
+                    }
+                }
+                mConferenceState++;
+                sendUnsolicitedResponse(ImsQmiIF.UNSOL_RESPONSE_CALL_STATE_CHANGED);
+                break;
+            case STATE_CONF_HOLDING_HOLDING:
+                log("STATE_CONF_HOLDING_HOLDING");
+                for (int i = 0; i < MAX_CALL_COUNTS; i++) {
+                    if (!mCalls[i].mIsActive) {
+                        mCalls[i].mIsMT = false;
+                        mCalls[i].mState = DriverCallIms.State.DIALING;
+                        mCalls[i].mIsMpty = true;
+                        mCalls[i].mNumber = "";
+                        mCalls[i].mIsVoice = true;
+                        mCalls[i].mName = "Conference";
+                        mCalls[i].mCall_type = CallDetails.CALL_TYPE_VOICE;
+                        mCalls[i].mCall_domain = CallDetails.CALL_DOMAIN_PS;
+                        mCalls[i].mExtras[0] = "Codec=AMR_WB";
+                        mCalls[i].mIsActive = true;
+                        mNumOfCalls++;
+                        break;
+                    }
+                }
+                mConferenceState++;
+                sendUnsolicitedResponse(ImsQmiIF.UNSOL_RESPONSE_CALL_STATE_CHANGED);
+                break;
+            case STATE_CONF_HOLDING_HOLDING_DIALING:
+                log("STATE_CONF_HOLDING_HOLDING_DIALING");
+                for (int i = 0; i < MAX_CALL_COUNTS; i++) {
+                    if (mCalls[i].mState == DriverCallIms.State.DIALING) {
+                        mCalls[i].mState = DriverCallIms.State.ACTIVE;
+                        break;
+                    }
+                }
+                mConferenceState++;
+                sendUnsolicitedResponse(ImsQmiIF.UNSOL_RESPONSE_CALL_STATE_CHANGED);
+                break;
+            case STATE_CONF_HOLDING_HOLDING_ACTIVE:
+                log("STATE_CONF_HOLDING_HOLDING_ACTIVE");
+                for (int i = 0; i < MAX_CALL_COUNTS; i++) {
+                    if (mCalls[i].mState == DriverCallIms.State.HOLDING) {
+                        hangupCall(i + 1);
+                        break;
+                    }
+                }
+                mConferenceState++;
+                sendUnsolicitedResponse(ImsQmiIF.UNSOL_RESPONSE_CALL_STATE_CHANGED);
+                break;
+            case STATE_CONF_END_HOLDING_ACTIVE:
+                log("STATE_CONF_END_HOLDING_ACTIVE");
+                for (int i = 0; i < MAX_CALL_COUNTS; i++) {
+                    if (mCalls[i].mState == DriverCallIms.State.HOLDING) {
+                        hangupCall(i + 1);
+                        break;
+                    }
+                }
+                mConferenceState++;
+                sendUnsolicitedResponse(ImsQmiIF.UNSOL_RESPONSE_CALL_STATE_CHANGED);
+                break;
+            case STATE_CONF_END_ACTIVE:
+                log("STATE_CONF_END_ACTIVE");
+                for (int i = 0; i < MAX_CALL_COUNTS; i++) {
+                    if (mCalls[i].mState == DriverCallIms.State.HOLDING) {
+                        hangupCall(i + 1);
+                        break;
+                    }
+                }
+                mConferenceState++;
+                sendUnsolicitedResponse(ImsQmiIF.UNSOL_RESPONSE_CALL_STATE_CHANGED);
+                break;
+            case STATE_CONF_ACTIVE:
+                log("STATE_CONF_ACTIVE");
+                mConferenceState = -1;
+                mIsRequestConference = false;
+                sendSolicitedResponse(mConfRequest);
+                break;
+            default:
+                // ERROR
+                break;
+            }
+        }
+    }
+
+
+    class MockIFMsg_Sender extends Handler implements Runnable {
+        public MockIFMsg_Sender(Looper looper) {
+            super(looper);
+        }
+
+        // ***** Runnable implementation
+        public void
+                run() {
+            // setup if needed
+        }
+
+        // ***** Handler implementation
+        @Override
+        public void handleMessage(Message msg) {
+            IFRequest rr;
+
+            try {
+                Thread.sleep(250 + mResponseDelayMillis);
+            } catch (InterruptedException e) {
+                // do nothing.
+            }
+
+            switch (msg.what) {
+            case EVENT_SEND_SOL_RESPONSE:
+                rr = (IFRequest) (msg.obj);
+                log("SOLICITED RESPONSE : " + msgIdToString(rr.mRequest));
+                sendSolicitedResponse(rr);
+                break;
+            case EVENT_SEND_UNSOL_RESPONSE:
+                int event = (int)(msg.arg1);
+                log("UNSOLICITED RESPONSE : " + msgIdToString(event));
+                notifyUnsolicitedResponse(event);
+                break;
+            }
+        }
+    }
+
+    /*
+     * Constructor
+     *
+     * @param context
+     */
+    public MockImsSenderRxr(Context context) {
+        super(context);
+        registerReceiver(context);
+
+        for (int i = 0; i < MAX_CALL_COUNTS; i++) {
+            mCalls[i] = new ImsCall();
+            mCalls[i].mIndex = i + 1;
+            mCalls[i].mCallMediaId = mCalls[i].mIndex;
+            mCalls[i].mFailCode.setFailcause(ImsQmiIF.CALL_FAIL_ERROR_UNSPECIFIED);
+            mCalls[i].mLocalAbility = getDefaultServiceStatusList().toArray(new ServiceStatus[0]);
+            mCalls[i].mPeerAbility = getDefaultServiceStatusList().toArray(new ServiceStatus[0]);
+        }
+
+        for (int j = 0; j < CF_REASON_COUNTS; j++) {
+            mCallForwardInfo[j] = new CallForwardInfo();
+            mCallForwardInfo[j].status = 0; // Not Active
+            // CF_REASON_UNCONDITIONAL    = 0;
+            // CF_REASON_BUSY             = 1;
+            // CF_REASON_NO_REPLY         = 2;
+            // CF_REASON_NOT_REACHABLE    = 3;
+            // CF_REASON_ALL              = 4;
+            // CF_REASON_ALL_CONDITIONAL  = 5;
+            mCallForwardInfo[j].reason = j;
+            mCallForwardInfo[j].serviceClass = SERVICE_CLASS_VOICE;
+            mCallForwardInfo[j].toa = 129;
+            mCallForwardInfo[j].number = "";
+            mCallForwardInfo[j].timeSeconds = 0;
+/* Depends on CRs-Fixed: 689110
+            mCallForwardInfo[j].startHour = 0;
+            mCallForwardInfo[j].startMinute = 0;
+            mCallForwardInfo[j].endHour = 0;
+            mCallForwardInfo[j].endMinute = 0;
+*/
+        }
+
+        mSenderThread = new HandlerThread("MockIFMsg_Sender");
+        mSenderThread.start();
+        Looper looper = mSenderThread.getLooper();
+        mSender = new MockIFMsg_Sender(looper);
+
+        mConfThread = new HandlerThread("ConferenceSender");
+        mConfThread.start();
+        Looper confLooper = mConfThread.getLooper();
+        mConfSender = new ConferenceSender(confLooper);
+    }
+
+    private void registerReceiver(Context c) {
+        IntentFilter filter = new IntentFilter();
+        filter.addAction(ACTION_IMS_STATE_CHANGED);
+        filter.addAction(ACTION_CALL_STATE_CHANGED);
+        filter.addAction(ACTION_DOWNGRADE_UPGRADE);
+        filter.addAction(ACTION_VIDEO_SHARE);
+        filter.addAction(ACTION_REJECT_DOWNGRADE_UPGRADE);
+        filter.addAction(ACTION_DELAY_RESPONSE);
+        filter.addAction(ACTION_NW_SERVICE_ERROR_MODE_CHANGED);
+        filter.addAction(ACTION_SUPP_SERVICE_NOTIFICATION);
+        filter.addAction(ACTION_REQ_ERROR_MODE_CHANGED);
+        c.registerReceiver(mTestCommandReceiver, filter);
+    }
+
+    /*
+     * Notifies the registrant of IMS registration state change,
+     * and notifies the registrant of Service status change.
+     *
+     * @param context
+     * @param intent
+     */
+    private void processImsStateChanged(Context context, Intent intent) {
+        log("[TEST COMMAND] ACTION_IMS_STATE_CHANGED");
+        String imsState = intent.getStringExtra(EXTRA_IMS_REG_STATE);
+        if (imsState == null) {
+            mImsRegState = 2;
+        } else {
+            mImsRegState = Integer.parseInt(imsState);
+        }
+
+        sendUnsolicitedResponse(ImsQmiIF.UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED);
+
+        if (mImsRegState == 2) {
+            Toast.makeText(context, "[IMS] Not Registered", Toast.LENGTH_LONG).show();
+        } else {
+            Toast.makeText(context, "[IMS] Registered", Toast.LENGTH_LONG).show();
+        }
+
+        sendUnsolicitedResponse(ImsQmiIF.UNSOL_SRV_STATUS_UPDATE);
+    }
+
+    /*
+     * Changes the current call state.
+     *
+     * @param intent
+     */
+    private void processCallStateChanged(Intent intent) {
+        log("[TEST COMMAND] ACTION_CALL_STATE_CHANGED");
+
+        String command = intent.getStringExtra(EXTRA_CALL_COMMAND);
+
+        if (TextUtils.isEmpty(command)) {
+            log("Invalid request!");
+            return;
+        }
+
+        String voiceCodec = intent.getStringExtra(EXTRA_VOICE_CODEC);
+        if (TextUtils.isEmpty(voiceCodec)) {
+            log("Voice codec is empty.");
+            voiceCodec = "Codec=AMR_WB";
+        }
+
+        if (CALL_COMMAND_ACCEPT_OR_INCOMING.equals(command)) {
+            log("[TEST COMMAND] CALL_COMMAND_ACCEPT_OR_INCOMING");
+            boolean isIncoming = true;
+            for (int i = 0; i < MAX_CALL_COUNTS; i++) {
+                if ((mCalls[i].mState != DriverCallIms.State.DIALING) &&
+                        (mCalls[i].mState != DriverCallIms.State.ALERTING)) {
+                    continue;
+                }
+                mCalls[i].mState = DriverCallIms.State.ACTIVE;
+                mCalls[i].mExtras[0] = voiceCodec;
+                isIncoming = false;
+                sendRingbackToneResponse(false);
+            }
+
+            // INCOMING CALL Request
+            if (isIncoming) {
+                makeIncomingCallOrWaitingCall(intent, voiceCodec);
+                sendUnsolicitedResponse(ImsQmiIF.UNSOL_CALL_RING);
+            }
+        } else if (CALL_COMMAND_ENDCALL.equals(command)) {
+            log("[TEST COMMAND] CALL_COMMAND_ENDCALL");
+            for (int i = 0; i < MAX_CALL_COUNTS; i++) {
+                if (!mCalls[i].mIsActive) {
+                    continue;
+                }
+                mCalls[i].mState = DriverCallIms.State.END;
+                String failCode = intent.getStringExtra(EXTRA_CALL_FAIL_CODE);
+                log("FAIL CODE: " + failCode);
+                if (TextUtils.isEmpty(failCode)) {
+                    hangupCall(i + 1, ImsQmiIF.CALL_FAIL_NORMAL);
+                } else {
+                    hangupCall(i + 1, Integer.parseInt(failCode));
+                }
+                break;
+            }
+        } else if (CALL_COMMAND_STATE_CHANGE.equals(command)) {
+            log("[TEST COMMAND] CALL_COMMAND_STATE_CHANGE : Voice codec is " + voiceCodec);
+
+            for (int i = 0; i < MAX_CALL_COUNTS; i++) {
+                if ((mCalls[i].mIsActive) && (mCalls[i].mState == DriverCallIms.State.ACTIVE)) {
+                    mCalls[i].mExtras[0] = voiceCodec;
+                    break;
+                }
+            }
+        } else {
+            // TODO
+            log("Not supported!");
+            return;
+        }
+
+        sendUnsolicitedResponse(ImsQmiIF.UNSOL_RESPONSE_CALL_STATE_CHANGED);
+    }
+
+    /*
+     * Downgrade or Upgrade the current active call.
+     *
+     * @param reject true if reject the request
+     * @param isVideoShare true if request Video sharing
+     */
+    private void processDowngradeUpgrade(boolean reject, boolean isVideoShare) {
+        mIsVideoShareRequest = false;
+        if (reject) {
+            log("[TEST COMMAND] ACTION_REJECT_DOWNGRADE_UPGRADE");
+            if (!mIsModifyCallRequested) {
+                log("Invalid request! mIsModifyCallRequested is " + mIsModifyCallRequested);
+                return;
+            }
+            mModifyCallRejected = true;
+        } else {
+            if (isVideoShare) {
+                log("[TEST COMMAND] ACTION_VIDEO_SHARE");
+                mIsVideoShareRequest = true;
+            } else {
+                log("[TEST COMMAND] ACTION_DOWNGRADE_UPGRADE");
+            }
+            if (!mIsModifyCallRequested) {
+                ImsCall callToModify = null;
+                for (ImsCall call : mCalls) {
+                    if (call.mIsActive && (call.mState == DriverCallIms.State.ACTIVE)) {
+                        callToModify = call;
+                        break;
+                    }
+                }
+                if (callToModify != null) {
+                    if (callToModify.mCall_type == CallDetails.CALL_TYPE_VOICE) {
+                        // Will upgrade to a video.
+                        sendUnsolicitedResponse(ImsQmiIF.UNSOL_MODIFY_CALL);
+                    } else {
+                        if (callToModify.mCall_type == CallDetails.CALL_TYPE_VT &&
+                                mIsVideoShareRequest) {
+                            callToModify.mCall_type = CallDetails.CALL_TYPE_VT_TX;
+                            callToModify.mIsVoice = false;
+                        } else if (callToModify.mCall_type == CallDetails.CALL_TYPE_VT_TX &&
+                                mIsVideoShareRequest) {
+                            callToModify.mCall_type = CallDetails.CALL_TYPE_VT;
+                            callToModify.mIsVoice = false;
+                        } else {
+                            callToModify.mCall_type = CallDetails.CALL_TYPE_VOICE;
+                            callToModify.mIsVoice = true;
+                        }
+                        // These should be processed in accordance with a call
+                        // state change sequence.
+                        sendUnsolicitedResponse(ImsQmiIF.UNSOL_RESPONSE_CALL_STATE_CHANGED);
+                    }
+                }
+            } else {
+                // Use mCallModify
+                for (int i = 0; i < MAX_CALL_COUNTS; i++) {
+                    if ((mCalls[i].mIndex == mCallModify.call_index) && mCalls[i].mIsActive) {
+                        if (mCallModify.call_details.call_type != CallDetails.CALL_TYPE_VOICE) {
+                            mCalls[i].mIsVoice = false;
+                        } else {
+                            mCalls[i].mIsVoice = true;
+                        }
+                        mCalls[i].mCall_type = mCallModify.call_details.call_type;
+                        mCalls[i].mCall_domain = mCallModify.call_details.call_domain;
+                        if (mCallModify.call_details.extras != null) {
+                            mCalls[i].mExtras[0] = mCallModify.call_details.extras[0];
+                        }
+                        break;
+                    }
+                }
+            }
+        }
+
+        if (mIsModifyCallRequested) {
+            mIsModifyCallRequested = false;
+            mCountDownLatch.countDown();
+        }
+    }
+
+    private void makeIncomingCallOrWaitingCall(Intent intent, String voiceCodec) {
+        for (int i = 0; i < MAX_CALL_COUNTS; i++) {
+            if (mCalls[i].mIsActive) {
+                continue;
+            }
+            if (mNumOfCalls > 0) {
+                mCalls[i].mState = DriverCallIms.State.WAITING;
+            } else {
+                mCalls[i].mState = DriverCallIms.State.INCOMING;
+            }
+            mCalls[i].mNumber = intent.getStringExtra(EXTRA_CALL_INCOMING_NUMBER);
+            if (!isPhoneNumberString(mCalls[i].mNumber)) {
+                mCalls[i].mNumber = null;
+            }
+
+            String numPresentation = intent.getStringExtra(EXTRA_CALL_NUMBER_PRESENTATION);
+            if (TextUtils.isEmpty(numPresentation)) {
+                mCalls[i].mNumberPresentation = 0;
+            } else {
+                mCalls[i].mNumberPresentation = Integer.parseInt(numPresentation);
+                if ((mCalls[i].mNumberPresentation < 0) ||
+                        (3 < mCalls[i].mNumberPresentation)) {
+                    mCalls[i].mNumberPresentation = 0;
+                }
+            }
+
+            mCalls[i].mName = intent.getStringExtra(EXTRA_CALL_INCOMING_NAME);
+            mCalls[i].mNamePresentation = intent.getIntExtra(EXTRA_CALL_NAME_PRESENTATION, 0);
+            if ((mCalls[i].mNamePresentation < 0) || (3 < mCalls[i].mNamePresentation)) {
+                mCalls[i].mNamePresentation = 0;
+            }
+
+            if (TYPE_VOICE.equals(intent.getStringExtra(EXTRA_CALL_INCOMING_TYPE))) {
+                mCalls[i].mIsVoice = true;
+                mCalls[i].mCall_type = CallDetails.CALL_TYPE_VOICE;
+            } else {
+                mCalls[i].mIsVoice = false;
+                mCalls[i].mCall_type = CallDetails.CALL_TYPE_VT;
+            }
+
+            mCalls[i].mIsMT = true;
+            mCalls[i].mIsActive = true;
+            mCalls[i].mExtras[0] = voiceCodec;
+            mNumOfCalls++;
+            break;
+        }
+    }
+
+    private void processDelayResponse(Context context, Intent intent) {
+        log("[TEST COMMAND] ACTION_DELAY_RESPONSE");
+        mResponseDelayMillis = intent.getIntExtra(EXTRA_DELAY, 0);
+        Toast.makeText(context, "Delay:" + mResponseDelayMillis,
+                Toast.LENGTH_LONG).show();
+    }
+
+    private void processNetworkServiceErrorMode(Context context, Intent intent) {
+        log("[TEST COMMAND] ACTION_NW_SERVICE_ERROR_MODE_CHANGED");
+        mErrorMode = intent.getBooleanExtra(EXTRA_ERROR_MODE, false);
+        String toastText = "";
+        if (mErrorMode) {
+            toastText = "[Error mode] ON";
+        } else {
+            toastText = "[Error mode] OFF";
+        }
+        Toast.makeText(context, toastText, Toast.LENGTH_SHORT).show();
+    }
+
+    private void processRequestErrorMode(Context context, Intent intent) {
+        log("[TEST COMMAND] ACTION_REQ_ERROR_MODE_CHANGED");
+        String request = intent.getStringExtra(EXTRA_REQ_FOR_ERROR);
+        boolean errorMode = intent.getBooleanExtra(EXTRA_REQ_ERROR_MODE, false);
+        boolean isException = intent.getBooleanExtra(EXTRA_REQ_ERROR_TYPE_EXCEPTION, false);
+
+        if (request == null) return;
+
+        if (request.equals("REQUEST_DIAL")) {
+            mErrorModeDial.mMode = errorMode;
+            mErrorModeDial.mIsException = isException;
+        } else if (request.equals("REQUEST_ANSWER")) {
+            mErrorModeAnswer.mMode = errorMode;
+            mErrorModeAnswer.mIsException = isException;
+        } else if (request.equals("REQUEST_HANGUP")) {
+            mErrorModeHangup.mMode = errorMode;
+            mErrorModeHangup.mIsException = isException;
+        } else if (request.equals("REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE")) {
+            mErrorModeSwitch.mMode = errorMode;
+            mErrorModeSwitch.mIsException = isException;
+        } else if (request.equals("REQUEST_HOLD")) {
+            mErrorModeHold.mMode = errorMode;
+            mErrorModeHold.mIsException = isException;
+        } else if (request.equals("REQUEST_RESUME")) {
+            mErrorModeResume.mMode = errorMode;
+            mErrorModeResume.mIsException = isException;
+        } else if (request.equals("REQUEST_CONFERENCE")) {
+            mErrorModeConference.mMode = errorMode;
+            mErrorModeConference.mIsException = isException;
+        } else if (request.equals("REQUEST_REQUEST_HANGUP_WAITING_OR_BACKGROUND")) {
+            mErrorModeHangupWaiting.mMode = errorMode;
+            mErrorModeHangupWaiting.mIsException = isException;
+        } else if (request.equals("REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND")) {
+            mErrorModeHangupForeResumeBack.mMode = errorMode;
+            mErrorModeHangupForeResumeBack.mIsException = isException;
+        } else {
+            Toast.makeText(context, "Not supported now.", Toast.LENGTH_SHORT).show();
+            return;
+        }
+
+        String toastText = "";
+        if (errorMode) {
+            toastText = "[Error mode][" + request + "] ON Exception=" + isException;
+        } else {
+            toastText = "[Error mode][" + request + "] OFF";
+        }
+        Toast.makeText(context, toastText, Toast.LENGTH_SHORT).show();
+    }
+
+    private void sendConferenceRequest() {
+        Message msg;
+        msg = mConfSender.obtainMessage(mConferenceState);
+        msg.sendToTarget();
+    }
+
+    /*
+     * Snatches all of ImsQmiIF requests.
+     *
+     * @param rr IFRequest
+     */
+    @Override
+    public void send(IFRequest rr) {
+        Message msg = mSender.obtainMessage(EVENT_SEND_SOL_RESPONSE, rr);
+        msg.sendToTarget();
+    }
+
+    private void sendUnsolicitedResponse(int event) {
+        Message msg;
+        msg = mSender.obtainMessage(EVENT_SEND_UNSOL_RESPONSE);
+        msg.arg1 = event;
+        msg.sendToTarget();
+    }
+
+    private void sendSolicitedResponse(IFRequest rr) {
+
+        Object ret = null;
+        RuntimeException ex = null;
+        int error = ImsQmiIF.E_SUCCESS;
+
+        switch (rr.mRequest) {
+        case ImsQmiIF.REQUEST_IMS_REGISTRATION_STATE:
+            ret = responseImsRegistration();
+            break;
+        case ImsQmiIF.REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND: {
+            if (mErrorModeHangupForeResumeBack.mMode) {
+                if (mErrorModeHangupForeResumeBack.mIsException) {
+                    ex = new RuntimeException(
+                            "[Mock][Error] REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND");
+                } else {
+                    error = ImsQmiIF.E_GENERIC_FAILURE;
+                }
+            }
+
+//            if (mTestingEmergencyCall.getAndSet(false)) {
+//                if (mEmergencyCallbackModeRegistrant != null) {
+//                    log("testing emergency call, notify ECM Registrants");
+//                    mEmergencyCallbackModeRegistrant.notifyRegistrant();
+//                }
+//            }
+            break;
+            }
+        case ImsQmiIF.REQUEST_GET_CURRENT_CALLS:
+            logCallList();
+            ret = responseCallList();
+            break;
+        case ImsQmiIF.REQUEST_LAST_CALL_FAIL_CAUSE:
+//            ret = responseCallFailCause(message);
+            break;
+        case ImsQmiIF.REQUEST_GET_CLIR:
+//            ret = responseGetClir(message);
+            break;
+        case ImsQmiIF.REQUEST_QUERY_CALL_FORWARD_STATUS:
+            ret = responseQueryCallForward();
+            if (mErrorMode) ex = new RuntimeException("[Mock] Error mode is ON.");
+            break;
+        case ImsQmiIF.REQUEST_QUERY_CALL_WAITING:
+            ret = responseQueryCallWaiting();
+            if (mErrorMode) ex = new RuntimeException("[Mock] Error mode is ON.");
+            break;
+        case ImsQmiIF.REQUEST_QUERY_CLIP:
+//            ret = responseQueryClip(message);
+            break;
+        case ImsQmiIF.REQUEST_QUERY_SERVICE_STATUS:
+//            ret = handleSrvStatus(message);
+            break;
+        case ImsQmiIF.REQUEST_SET_CALL_FORWARD_STATUS:
+        case ImsQmiIF.REQUEST_SET_CALL_WAITING:
+        case ImsQmiIF.REQUEST_SUPP_SVC_STATUS:
+//            ret = responseSuppSvcStatus(message);
+            if (mErrorMode) ex = new RuntimeException("[Mock] Error mode is ON.");
+            break;
+// Remove existing API's REQUEST_QUERY_VT_CALL_QUALITY and REQUEST_SET_VT_CALL_QUALITY
+// Change-Id: I7f78cae40b56e5891c6e166ca74a768242dd8d08
+//        case ImsQmiIF.REQUEST_QUERY_VT_CALL_QUALITY:
+//            ret = responseQueryVideoCallQuality(message);
+//            break;
+        case ImsQmiIF.REQUEST_GET_COLR:
+//            ret = responseGetColr(message);
+            break;
+        case ImsQmiIF.REQUEST_SET_SERVICE_STATUS:
+        case ImsQmiIF.REQUEST_SEND_UI_TTY_MODE:
+        case ImsQmiIF.REQUEST_DEFLECT_CALL:
+        case ImsQmiIF.REQUEST_ADD_PARTICIPANT:
+            break;
+        case ImsQmiIF.REQUEST_DIAL:
+            if (mErrorModeDial.mMode) {
+                if (mErrorModeDial.mIsException) {
+                    ex = new RuntimeException("[Mock][Error] REQUEST_DIAL");
+                } else {
+                    error = ImsQmiIF.E_GENERIC_FAILURE;
+                }
+            }
+            break;
+        case ImsQmiIF.REQUEST_ANSWER:
+            if (mErrorModeAnswer.mMode) {
+                if (mErrorModeAnswer.mIsException) {
+                    ex = new RuntimeException("[Mock][Error] REQUEST_ANSWER");
+                } else {
+                    error = ImsQmiIF.E_GENERIC_FAILURE;
+                }
+            }
+            break;
+        case ImsQmiIF.REQUEST_HANGUP:
+            if (mErrorModeHangup.mMode) {
+                if (mErrorModeHangup.mIsException) {
+                    ex = new RuntimeException("[Mock][Error] REQUEST_HANGUP");
+                } else {
+                    error = ImsQmiIF.E_GENERIC_FAILURE;
+                }
+            }
+            break;
+        case ImsQmiIF.REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE:
+            if (mErrorModeSwitch.mMode) {
+                if (mErrorModeSwitch.mIsException) {
+                    ex = new RuntimeException(
+                            "[Mock][Error] REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE");
+                } else {
+                    error = ImsQmiIF.E_GENERIC_FAILURE;
+                }
+            }
+            break;
+        case ImsQmiIF.REQUEST_RESUME:
+            if (mErrorModeResume.mMode) {
+                if (mErrorModeResume.mIsException) {
+                    ex = new RuntimeException("[Mock][Error] REQUEST_RESUME");
+                } else {
+                    error = ImsQmiIF.E_GENERIC_FAILURE;
+                }
+            }
+            break;
+        case ImsQmiIF.REQUEST_HOLD:
+            if (mErrorModeHold.mMode) {
+                if (mErrorModeHold.mIsException) {
+                    ex = new RuntimeException("[Mock][Error] REQUEST_HOLD");
+                } else {
+                    error = ImsQmiIF.E_GENERIC_FAILURE;
+                }
+            }
+            break;
+        case ImsQmiIF.REQUEST_CONFERENCE:
+            if (mErrorModeConference.mMode) {
+                if (mErrorModeConference.mIsException) {
+                    ex = new RuntimeException("[Mock][Error] REQUEST_CONFERENCE");
+                } else {
+                    error = ImsQmiIF.E_GENERIC_FAILURE;
+                }
+            } else {
+                if (mIsRequestConference) {
+                    mConfRequest = rr;
+                    mConferenceState = STATE_CONF_ACTIVE_HOLDING;
+                    sendConferenceRequest();
+                    return;
+                }
+            }
+            break;
+        case ImsQmiIF.REQUEST_HANGUP_WAITING_OR_BACKGROUND:
+            if (mErrorModeHangupWaiting.mMode) {
+                if (mErrorModeHangupWaiting.mIsException) {
+                    ex = new RuntimeException(
+                            "[Mock][Error] REQUEST_HANGUP_WAITING_OR_BACKGROUND");
+                } else {
+                    error = ImsQmiIF.E_GENERIC_FAILURE;
+                }
+            }
+            break;
+        case ImsQmiIF.REQUEST_EXIT_EMERGENCY_CALLBACK_MODE:
+        case ImsQmiIF.REQUEST_DTMF:
+        case ImsQmiIF.REQUEST_DTMF_START:
+        case ImsQmiIF.REQUEST_DTMF_STOP:
+            // no data
+            break;
+        case ImsQmiIF.REQUEST_MODIFY_CALL_INITIATE:
+            if (mIsModifyCallRequested) {
+                log("[REQUEST_MODIFY_CALL_INITIATE] Wait for test command.");
+                if (mCountDownLatch == null) {
+                    try {
+                        mCountDownLatch = new CountDownLatch(1);
+                        mCountDownLatch.await();
+                    } catch (InterruptedException e) {
+                        // do nothing
+                    }
+                    log("[REQUEST_MODIFY_CALL_INITIATE] Test command has been received.");
+                    if (mModifyCallRejected) {
+                        ex = new ImsRilException(ImsQmiIF.E_REJECTED_BY_REMOTE,
+                                ImsSenderRxr.errorIdToString(ImsQmiIF.E_REJECTED_BY_REMOTE));
+                        mModifyCallRejected = false;
+                    }
+                    mCountDownLatch = null;
+                    mIsModifyCallRequested = false;
+                } else {
+                    log("[REQUEST_MODIFY_CALL_INITIATE] mCountDownLatch is not null.");
+                }
+            }
+            break;
+        case ImsQmiIF.REQUEST_MODIFY_CALL_CONFIRM:
+        case ImsQmiIF.REQUEST_SET_CLIR:
+        case ImsQmiIF.REQUEST_IMS_REG_STATE_CHANGE:
+        case ImsQmiIF.REQUEST_SET_SUPP_SVC_NOTIFICATION:
+// Remove existing API's REQUEST_QUERY_VT_CALL_QUALITY and REQUEST_SET_VT_CALL_QUALITY
+//Add video quality support as part of REQUEST_SET_IMS_CONFIG and REQUEST_GET_IMS_CONFIG
+// Change-Id: I7f78cae40b56e5891c6e166ca74a768242dd8d08
+//        case ImsQmiIF.REQUEST_SET_VT_CALL_QUALITY:
+        case ImsQmiIF.REQUEST_SET_COLR:
+            // no data
+            break;
+        case ImsQmiIF.REQUEST_SET_IMS_CONFIG:
+        case ImsQmiIF.REQUEST_GET_IMS_CONFIG:
+//            ret = responseConfig(message);
+            break;
+        default:
+            log("Invalid Request! [" + rr.mRequest + "]");
+            break;
+        }
+
+        if (error != ImsQmiIF.E_SUCCESS) {
+            rr.onError(error, ret);
+            rr.release();
+            return;
+        }
+
+        log(rr.serialString() + "< " + msgIdToString(rr.mRequest)
+                + " " + retToString(rr.mRequest, ret));
+
+        if (rr.mResult != null) {
+            AsyncResult.forMessage(rr.mResult, ret, ex);
+            rr.mResult.sendToTarget();
+        }
+
+        // Notify unsolicited response
+        switch (rr.mRequest) {
+        case ImsQmiIF.REQUEST_DIAL:
+        case ImsQmiIF.REQUEST_ANSWER:
+        case ImsQmiIF.REQUEST_HANGUP:
+        case ImsQmiIF.REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE:
+        case ImsQmiIF.REQUEST_HOLD:
+        case ImsQmiIF.REQUEST_RESUME:
+        case ImsQmiIF.REQUEST_MODIFY_CALL_INITIATE:
+        case ImsQmiIF.REQUEST_MODIFY_CALL_CONFIRM:
+            sendUnsolicitedResponse(ImsQmiIF.UNSOL_RESPONSE_CALL_STATE_CHANGED);
+            break;
+        }
+
+        rr.release();
+    }
+
+    private Object responseImsRegistration() {
+        int[] response = new int[1];
+        response[0] = mImsRegState;
+        return response;
+    }
+
+    private Object responseCallList() {
+        ArrayList<DriverCallIms> response = null;
+
+        if (mNumOfCalls > 0) {
+            DriverCallIms dc;
+            response = new ArrayList<DriverCallIms>(mNumOfCalls);
+            for (int i = 0; i < MAX_CALL_COUNTS; i++) {
+                if (mCalls[i].mIsActive) {
+                    dc = new DriverCallIms();
+                    dc.state = mCalls[i].mState;
+                    dc.index = mCalls[i].mIndex;
+                    dc.TOA = mCalls[i].mTOA;
+                    dc.isMpty = mCalls[i].mIsMpty;
+                    dc.isMT = mCalls[i].mIsMT;
+                    dc.als = mCalls[i].mAls;
+                    dc.isVoice = mCalls[i].mIsVoice;
+                    dc.isVoicePrivacy = mCalls[i].mIsVoicePrivacy;
+                    dc.number = null;
+                    dc.number = mCalls[i].mNumber;
+                    dc.numberPresentation = mCalls[i].mNumberPresentation + 1;
+                    dc.name = mCalls[i].mName;
+                    dc.namePresentation = mCalls[i].mNamePresentation + 1;
+
+                    dc.callDetails = new CallDetails();
+                    dc.callDetails.call_type = mCalls[i].mCall_type;
+                    dc.callDetails.call_domain = mCalls[i].mCall_domain;
+                    dc.callDetails.callMediaId = mCalls[i].mCallMediaId;
+                    dc.callDetails.extras = new String[1];
+                    dc.callDetails.extras[0] = mCalls[i].mExtras[0];
+                    dc.callDetails.localAbility = mCalls[i].mLocalAbility;
+                    dc.callDetails.peerAbility = mCalls[i].mPeerAbility;
+                    log("Call Details = " + dc.callDetails);
+                    dc.number = PhoneNumberUtils.stringFromStringAndTOA(dc.number, dc.TOA);
+
+                    dc.callFailCause =
+                            new ImsReasonInfo(ImsReasonInfo.CODE_UNSPECIFIED, 0);
+                    dc.callFailCause.mCode = getImsReasonForCallFailCause(mCalls[i].mFailCode);
+                    dc.callFailCause.mExtraMessage = mCalls[i].mFailCauseExtraMsg;
+
+                    log("dc = " + dc);
+                    response.add(dc);
+
+                    if (dc.isVoicePrivacy) {
+                        mVoicePrivacyOnRegistrants.notifyRegistrants();
+                        log("InCall VoicePrivacy is enabled");
+                    } else {
+                        mVoicePrivacyOffRegistrants.notifyRegistrants();
+                        log("InCall VoicePrivacy is disabled");
+                    }
+                }
+            }
+            Collections.sort(response);
+        } else {
+            response = new ArrayList<DriverCallIms>(0); //empty array
+        }
+
+        return response;
+    }
+
+    private Object responseQueryCallWaiting() {
+        int[] response = null;
+
+        if (!mCallWaiting) {
+            response = new int[1];
+            response[0] = ImsQmiIF.DISABLED; // 0
+        } else {
+            response = new int[2];
+            response[0] = ImsQmiIF.ENABLED; // 1
+            response[1] = SERVICE_CLASS_VOICE;
+        }
+        return response;
+    }
+
+    private Object responseQueryCallForward() {
+
+        CallForwardInfo infos[] = null;
+        int numInfos = 1;
+
+        infos = new CallForwardInfo[numInfos];
+        infos[0] = new CallForwardInfo();
+        infos[0].status = mCallForwardInfo[mQueryCfReason].status;
+        infos[0].reason = mCallForwardInfo[mQueryCfReason].reason;
+        infos[0].serviceClass = mCallForwardInfo[mQueryCfReason].serviceClass;
+        infos[0].toa = mCallForwardInfo[mQueryCfReason].toa;
+        infos[0].number = mCallForwardInfo[mQueryCfReason].number;
+        infos[0].timeSeconds = mCallForwardInfo[mQueryCfReason].timeSeconds;
+/* Depends on CRs-Fixed: 689110
+        infos[0].startHour = mCallForwardInfo[mQueryCfReason].startHour ;
+        infos[0].startMinute = mCallForwardInfo[mQueryCfReason].startMinute;
+        infos[0].endHour = mCallForwardInfo[mQueryCfReason].endHour;
+        infos[0].endMinute = mCallForwardInfo[mQueryCfReason].endMinute;
+*/
+        return infos;
+    }
+
+    @Override
+    public void
+    dial(String address, int clirMode, CallDetails callDetails,
+            Message result) {
+        dial(address, callDetails);
+        super.dial(address, clirMode, callDetails, result);
+    }
+
+    private void dial(String address, CallDetails callDetails) {
+
+        if (mErrorModeDial.mMode) return;
+
+        for (int i = 0; i < MAX_CALL_COUNTS; i++) {
+
+            if (mCalls[i].mIsActive) {
+                continue;
+            }
+
+            mCalls[i].mState = DriverCallIms.State.DIALING;
+            mCalls[i].mNumber = address;
+
+            if (callDetails.call_type == CallDetails.CALL_TYPE_VOICE) {
+                mCalls[i].mIsVoice = true;
+            } else {
+                mCalls[i].mIsVoice = false;
+            }
+
+            mCalls[i].mCall_type = callDetails.call_type;
+
+            mCalls[i].mIsActive = true;
+            mNumOfCalls++;
+            break;
+        }
+
+        // Notify ALERTING 1 sec later.
+        if (mTimer != null) {
+            mTimer.schedule(new TimerTask() {
+                @Override
+                public void run() {
+                    boolean changedToAlerting = false;
+                    for (int i = 0; i < MAX_CALL_COUNTS; i++) {
+                        if (mCalls[i].mState == DriverCallIms.State.DIALING) {
+                            mCalls[i].mState = DriverCallIms.State.ALERTING;
+                            changedToAlerting = true;
+                            break;
+                        }
+                    }
+                    sendUnsolicitedResponse(ImsQmiIF.UNSOL_RESPONSE_CALL_STATE_CHANGED);
+
+                    // Notify RINGBACK_TONE a little later from ALERTING.
+                    if (changedToAlerting) {
+                        mTimer.schedule(new TimerTask() {
+                            @Override
+                            public void run() {
+                                sendRingbackToneResponse(true);
+                            }
+                        }, 500);
+                    }
+                }
+            }, 1000);
+        }
+    }
+
+    @Override
+    public void
+    acceptCall(Message result, int callType) {
+        if (!mErrorModeAnswer.mMode) {
+            for (int i = 0; i < MAX_CALL_COUNTS; i++) {
+                if ((mCalls[i].mState != DriverCallIms.State.INCOMING) &&
+                        (mCalls[i].mState != DriverCallIms.State.WAITING)) {
+                    continue;
+                }
+                mCalls[i].mState = DriverCallIms.State.ACTIVE;
+                mCalls[i].mCall_type = callType;
+                break;
+            }
+        }
+        super.acceptCall(result, callType);
+    }
+
+    @Override
+    public void modifyCallInitiate(Message result, CallModify callModify) {
+        if (mIsModifyCallRequested) {
+            log("Ignored! MODIFY_CALL_INITIATE is already requested!");
+            return;
+        }
+
+        mCallModify = callModify;
+        mIsModifyCallRequested = true;
+        mModifyCallRejected = false;
+        super.modifyCallInitiate(result, callModify);
+    }
+
+    @Override
+    public void modifyCallConfirm(Message result, CallModify callModify) {
+        for (int i = 0; i < MAX_CALL_COUNTS; i++) {
+            if (mCalls[i].mIndex == callModify.call_index) {
+                if (callModify.call_details.call_type != CallDetails.CALL_TYPE_VOICE) {
+                    mCalls[i].mIsVoice = false;
+                } else {
+                    mCalls[i].mIsVoice = true;
+                }
+
+                mCalls[i].mCall_type = callModify.call_details.call_type;
+                mCalls[i].mCall_domain = callModify.call_details.call_domain;
+
+                if (callModify.call_details.extras != null) {
+                    mCalls[i].mExtras[0] = callModify.call_details.extras[0];
+                }
+                break;
+            }
+        }
+        super.modifyCallConfirm(result, callModify);
+    }
+
+    @Override
+    public void switchWaitingOrHoldingAndActive(Message result, int callType) {
+        switchWaitingOrHoldingAndActive();
+        super.switchWaitingOrHoldingAndActive(result, callType);
+    }
+
+    @Override
+    public void switchWaitingOrHoldingAndActive(Message result) {
+        switchWaitingOrHoldingAndActive();
+        super.switchWaitingOrHoldingAndActive(result);
+    }
+
+    private void switchWaitingOrHoldingAndActive() {
+
+        if (mErrorModeSwitch.mMode) return;
+
+        for (int i = 0; i < MAX_CALL_COUNTS; i++) {
+            if (mCalls[i].mState == DriverCallIms.State.WAITING) {
+                mCalls[i].mState = DriverCallIms.State.ACTIVE;
+                continue;
+            }
+            if (mCalls[i].mState == DriverCallIms.State.HOLDING) {
+                mCalls[i].mState = DriverCallIms.State.ACTIVE;
+                continue;
+            }
+            if (mCalls[i].mState == DriverCallIms.State.ACTIVE) {
+                mCalls[i].mState = DriverCallIms.State.HOLDING;
+                continue;
+            }
+        }
+    }
+
+    @Override
+    public void hold(Message result, int callId) {
+        if (!mErrorModeHold.mMode) {
+            for (int i = 0; i < MAX_CALL_COUNTS; i++) {
+                if (mCalls[i].mIndex == callId) {
+                    mCalls[i].mState = DriverCallIms.State.HOLDING;
+                }
+            }
+        }
+        super.hold(result, callId);
+    }
+
+    @Override
+    public void resume(Message result, int callId) {
+        if (!mErrorModeResume.mMode) {
+            for (int i = 0; i < MAX_CALL_COUNTS; i++) {
+                if (mCalls[i].mIndex == callId) {
+                    mCalls[i].mState = DriverCallIms.State.ACTIVE;
+                }
+            }
+        }
+        super.resume(result, callId);
+    }
+
+    @Override
+    public void
+    hangupConnection(int index, Message result) {
+        if (!mErrorModeHangup.mMode) {
+            hangupCall(index);
+        }
+        super.hangupConnection(index, result);
+    }
+
+    @Override
+    public void
+    hangupWithReason(int connectionId, String userUri, String confUri,
+            boolean mpty, int failCause, String errorInfo, Message result) {
+        if (!mErrorModeHangup.mMode) {
+            hangupCall(connectionId);
+        }
+        super.hangupWithReason(connectionId, userUri, confUri, mpty, failCause, errorInfo, result);
+    }
+
+    @Override
+    public void hangupForegroundResumeBackground(Message result) {
+        if (!mErrorModeHangupForeResumeBack.mMode) {
+            for (int i = 0; i < MAX_CALL_COUNTS; i++) {
+                if (mCalls[i].mState == DriverCallIms.State.HOLDING) {
+                    mCalls[i].mState = DriverCallIms.State.ACTIVE;
+                    continue;
+                }
+                if (mCalls[i].mState != DriverCallIms.State.ACTIVE) {
+                    continue;
+                }
+                hangupCall(i + 1);
+            }
+        }
+        super.hangupForegroundResumeBackground(result);
+    }
+
+    @Override
+    public void hangupWaitingOrBackground(Message result) {
+        if (!mErrorModeHangupWaiting.mMode) {
+            for (int i = 0; i < MAX_CALL_COUNTS; i++) {
+                if ((mCalls[i].mState != DriverCallIms.State.WAITING) &&
+                        (mCalls[i].mState != DriverCallIms.State.INCOMING)) {
+                    continue;
+                }
+                hangupCall(i + 1);
+                break;
+            }
+        }
+        super.hangupWaitingOrBackground(result);
+    }
+
+    @Override
+    public void conference(Message result) {
+        if (!mErrorModeConference.mMode) {
+            mIsRequestConference = true;
+        }
+        super.conference(result);
+    }
+
+    void cleanupEndedCall() {
+        for (int i = 0; i < MAX_CALL_COUNTS; i++) {
+            if (mCalls[i].mState == DriverCallIms.State.END) {
+                mCalls[i].mIsMT = false;
+                mCalls[i].mState = null;
+                mCalls[i].mIsMpty = false;
+                mCalls[i].mNumber = null;
+                mCalls[i].mTOA = 129;
+                mCalls[i].mIsVoice = true;
+                mCalls[i].mIsVoicePrivacy = false;
+                mCalls[i].mAls = 0;
+                mCalls[i].mNumberPresentation = 0;
+                mCalls[i].mName = "";
+                mCalls[i].mNamePresentation = 0;
+                mCalls[i].mCall_type = CallDetails.CALL_TYPE_VOICE;
+                mCalls[i].mCall_domain = CallDetails.CALL_DOMAIN_PS;
+                mCalls[i].mExtras[0] = "Codec=AMR_WB";
+                mCalls[i].mVideoPauseState = CallDetails.VIDEO_PAUSE_STATE_RESUMED;
+                mCalls[i].mIsActive = false;
+                mCalls[i].mFailCode.setFailcause(ImsQmiIF.CALL_FAIL_ERROR_UNSPECIFIED);
+                mNumOfCalls--;
+                break;
+            }
+        }
+    }
+
+    void hangupCall(int index) {
+        hangupCall(index, ImsQmiIF.CALL_FAIL_NORMAL);
+    }
+
+    void hangupCall(int index, int failCause) {
+        for (int i = 0; i < MAX_CALL_COUNTS; i++) {
+            if (mCalls[i].mIndex == index) {
+                mCalls[i].mState = DriverCallIms.State.END;
+                mCalls[i].mFailCode.setFailcause(failCause);
+                sendRingbackToneResponse(false);
+                break;
+            }
+        }
+    }
+
+    private void logCallList() {
+        for (int i = 0; i < MAX_CALL_COUNTS; i++) {
+            log("[CallList] isActive=" + mCalls[i].mIsActive +
+                    " Index=" + mCalls[i].mIndex +
+                    " mIsMT=" + mCalls[i].mIsMT +
+                    " mState=" + mCalls[i].mState +
+                    " mIsMpty=" + mCalls[i].mIsMpty +
+                    " mNumber=" + mCalls[i].mNumber +
+                    " mName=" + mCalls[i].mName +
+                    " mIsVoice=" + mCalls[i].mIsVoice +
+                    " mNumberPresentation=" + mCalls[i].mNumberPresentation +
+                    " mNamePresentation=" + mCalls[i].mNamePresentation +
+                    " mCall_type=" + mCalls[i].mCall_type +
+                    " mCall_domain=" + mCalls[i].mCall_domain);
+        }
+        log("[CallList] Num of Calls=" + mNumOfCalls);
+    }
+
+
+    @Override
+    public void setCallWaiting(boolean enable, int serviceClass,
+            Message response) {
+        mCallWaiting = enable;
+        super.setCallWaiting(enable, serviceClass, response);
+    }
+
+    @Override
+    public void setCallForward(int action, int cfReason, int serviceClass,
+            String number, int timeSeconds, Message response) {
+
+        for (int i = 0; i < CF_REASON_COUNTS; i++) {
+            if (mCallForwardInfo[i].reason == cfReason) {
+                switch (action) {
+                case CF_ACTION_DISABLE:
+                    mCallForwardInfo[i].status = 0;
+                    mCallForwardInfo[i].number = number;
+                    if (mCallForwardInfo[i].number == null) {
+                        mCallForwardInfo[i].number = "";
+                    }
+                    mCallForwardInfo[i].timeSeconds = timeSeconds;
+                    break;
+                case CF_ACTION_ENABLE:
+                case CF_ACTION_REGISTRATION:
+                    mCallForwardInfo[i].status = 1;
+                    mCallForwardInfo[i].number = number;
+                    if (mCallForwardInfo[i].number == null) {
+                        mCallForwardInfo[i].number = "";
+                    }
+                    mCallForwardInfo[i].timeSeconds = timeSeconds;
+                    break;
+                case CF_ACTION_ERASURE:
+                    mCallForwardInfo[i].status = 0;
+                    mCallForwardInfo[i].number = "";
+                    mCallForwardInfo[i].timeSeconds = 0;
+                    break;
+                }
+                break;
+            }
+        }
+        super.setCallForward(action, cfReason, serviceClass, number, timeSeconds, response);
+    }
+
+    @Override
+    public void queryCallForwardStatus(int cfReason, int serviceClass,
+            String number, Message response) {
+
+        mQueryCfReason = cfReason;
+
+        super.queryCallForwardStatus(cfReason, serviceClass, number, response);
+    }
+
+    /*
+     * Notifies the registrants of unsolicited response.
+     *
+     * @param response
+     */
+    void notifyUnsolicitedResponse(int response) {
+
+        Object ret = null;
+
+        switch (response) {
+        case ImsQmiIF.UNSOL_RINGBACK_TONE:
+            ret = responseCallRingback();
+            break;
+        case ImsQmiIF.UNSOL_CALL_RING:
+        case ImsQmiIF.UNSOL_RESPONSE_CALL_STATE_CHANGED:
+            logCallList();
+            ret = responseCallList();
+            if (mIsRequestConference) {
+                sendConferenceRequest();
+            }
+            break;
+        case ImsQmiIF.UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED:
+        case ImsQmiIF.UNSOL_ENTER_EMERGENCY_CALLBACK_MODE:
+        case ImsQmiIF.UNSOL_EXIT_EMERGENCY_CALLBACK_MODE:
+            ret = null;
+            break;
+        case ImsQmiIF.UNSOL_MODIFY_CALL:
+            ret = responseModifyCall();
+            unsljLogRet(response, ret);
+            mModifyCallRegistrants
+                    .notifyRegistrants(new AsyncResult(null, ret, null));
+            break;
+        case ImsQmiIF.UNSOL_RESPONSE_HANDOVER:
+        case ImsQmiIF.UNSOL_REFRESH_CONF_INFO:
+            // Not supported.
+            break;
+        case ImsQmiIF.UNSOL_SRV_STATUS_UPDATE:
+            ret = handleSrvStatus(null);
+            break;
+        case ImsQmiIF.UNSOL_TTY_NOTIFICATION:
+        case ImsQmiIF.UNSOL_SUPP_SVC_NOTIFICATION:
+        case ImsQmiIF.UNSOL_RADIO_STATE_CHANGED:
+            // Not supported.
+            break;
+        default:
+            break;
+        }
+
+        switch (response) {
+        case ImsQmiIF.UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED:
+            unsljLog(response);
+            ImsQmiIF.Registration registration = new ImsQmiIF.Registration();
+            if (mImsRegState == 2) {
+                registration.setState(ImsQmiIF.Registration.NOT_REGISTERED);
+            } else {
+                registration.setState(ImsQmiIF.Registration.REGISTERED);
+            }
+            mImsNetworkStateChangedRegistrants
+                    .notifyRegistrants(new AsyncResult(null, registration, null));
+            break;
+        case ImsQmiIF.UNSOL_RESPONSE_CALL_STATE_CHANGED:
+            unsljLogRet(response, ret);
+            mCallStateRegistrants
+                    .notifyRegistrants(new AsyncResult(null, ret, null));
+            cleanupEndedCall();
+            break;
+        case ImsQmiIF.UNSOL_CALL_RING:
+            unsljLogRet(response, ret);
+            if (mRingRegistrant != null) {
+                mRingRegistrant.notifyRegistrant(
+                        new AsyncResult(null, ret, null));
+            }
+            break;
+        case ImsQmiIF.UNSOL_ENTER_EMERGENCY_CALLBACK_MODE:
+            unsljLog(response);
+            if (mEmergencyCallbackModeRegistrant != null) {
+                mEmergencyCallbackModeRegistrant.notifyRegistrant();
+            }
+            break;
+        case ImsQmiIF.UNSOL_RINGBACK_TONE:
+            unsljLogvRet(response, ret);
+            boolean playtone = false;
+            if (ret != null) playtone = (((int[]) ret)[0] == 1);
+            if (mRingbackToneRegistrants != null) {
+                mRingbackToneRegistrants.notifyRegistrants(
+                        new AsyncResult(null, playtone, null));
+            }
+            break;
+        case ImsQmiIF.UNSOL_EXIT_EMERGENCY_CALLBACK_MODE:
+            unsljLogRet(response, ret);
+            if (mExitEmergencyCallbackModeRegistrants != null) {
+                mExitEmergencyCallbackModeRegistrants.notifyRegistrants(
+                        new AsyncResult(null, null, null));
+            }
+            break;
+        case ImsQmiIF.UNSOL_RESPONSE_HANDOVER:
+        case ImsQmiIF.UNSOL_REFRESH_CONF_INFO:
+            // Not supported.
+            break;
+        case ImsQmiIF.UNSOL_SRV_STATUS_UPDATE:
+            unsljLogRet(response, ret);
+            mSrvStatusRegistrations
+                    .notifyRegistrants(new AsyncResult(null, ret, null));
+            break;
+        case ImsQmiIF.UNSOL_TTY_NOTIFICATION:
+            // Not supported.
+            break;
+        case ImsQmiIF.UNSOL_SUPP_SVC_NOTIFICATION:
+            if (mSsnRegistrant != null) {
+                mSsnRegistrant.notifyRegistrant(new AsyncResult (null, ret, null));
+            }
+            break;
+        }
+    }
+
+
+    private Object responseModifyCall() {
+        CallModify callModify = new CallModify();
+        for (int i = 0; i < MAX_CALL_COUNTS; i++) {
+            if (mCalls[i].mIsActive && (mCalls[i].mState == DriverCallIms.State.ACTIVE)) {
+                if (mCalls[i].mIsVoice) {
+                    // Switch to Video
+                    if (mIsVideoShareRequest) {
+                        // Share Video
+                        callModify.call_details.call_type = CallDetails.CALL_TYPE_VT_RX;
+                    } else {
+                        callModify.call_details.call_type = CallDetails.CALL_TYPE_VT;
+                    }
+                    callModify.call_details.call_domain = CallDetails.CALL_DOMAIN_PS;
+                } else {
+                    // Switch to Voice
+                    callModify.call_details.call_type = CallDetails.CALL_TYPE_VOICE;
+                }
+                callModify.call_details.call_domain = CallDetails.CALL_DOMAIN_PS;
+                callModify.call_details.extras = new String[] {"Codec=AMR_WB"};
+                callModify.call_index = mCalls[i].mIndex;
+                callModify.error = ImsQmiIF.E_SUCCESS;
+                log("responseModifyCall " + callModify);
+                break;
+            }
+        }
+
+        return callModify;
+    }
+
+    @Override
+    protected Object handleSrvStatus(byte[] updateList) {
+        return getDefaultServiceStatusList();
+    }
+
+    private ArrayList<ServiceStatus> getDefaultServiceStatusList() {
+        // CALL_TYPE_VOICE = 0; - Voice only call
+        // CALL_TYPE_VT_TX = 1; - PS Video telephony call: one way TX video, two way audio
+        // CALL_TYPE_VT_RX = 2; - Video telephony call: one way RX video, two way audio
+        // CALL_TYPE_VT = 3;    - Video telephony call: two way video, two way audio
+        // CALL_TYPE_VT_NODIR = 4; - Video telephony call: no direction two way audiotwo way audio
+        //                           intermediate state in a video call till video link is setup
+        // CALL_TYPE_SMS = 10;  - SMS
+        int[] srvStatusCallType = {0, 1, 2, 3, 4, 10};
+        int num = srvStatusCallType.length;
+        ArrayList<ServiceStatus> srvStList = new ArrayList<ServiceStatus>(num);
+        ServiceStatus srvSt;
+
+        for (int i = 0; i < num; i++) {
+            srvSt = new ServiceStatus();
+            srvSt.isValid = true;
+            srvSt.type = srvStatusCallType[i];
+            srvSt.status = ImsQmiIF.STATUS_ENABLED;
+            srvSt.userdata = null;
+            log("isValid = " + srvSt.isValid + " type = " + srvSt.type + " status = " +
+                    srvSt.status + " userdata = " + srvSt.userdata);
+
+            unpackAccTechStatus(srvSt);
+            srvStList.add(srvSt);
+        }
+
+        return srvStList;
+    }
+
+    private void unpackAccTechStatus(ServiceStatus srvSt) {
+        int numAccessTechUpdate = 1;
+
+        srvSt.accessTechStatus = new ServiceStatus.
+                StatusForAccessTech[numAccessTechUpdate];
+        for (int j = 0; j < numAccessTechUpdate; j++) {
+            srvSt.accessTechStatus[j] = new ServiceStatus.
+                    StatusForAccessTech();
+
+            // STATUS_DISABLED = 0;
+            // STATUS_PARTIALLY_ENABLED = 1;
+            // STATUS_ENABLED = 2;
+            // STATUS_NOT_SUPPORTED = 3;
+            if (mImsRegState != 1) {
+                // IMS : NOT_REGISTERED
+                srvSt.accessTechStatus[j].networkMode = -1; // RADIO_TECH_ANY = -1
+                srvSt.accessTechStatus[j].status = 0; // STATUS_DISABLED = 0
+            } else {
+                // IMS : REGISTERED
+                srvSt.accessTechStatus[j].networkMode = 14; // RADIO_TECH_LTE = 14
+                srvSt.accessTechStatus[j].status = 2; // STATUS_ENABLED = 2
+            }
+
+            srvSt.accessTechStatus[j].restrictCause = 0;
+            srvSt.accessTechStatus[j].registered = mImsRegState;
+
+            log(" networkMode = " + srvSt.accessTechStatus[j].networkMode +
+                    " status = " + srvSt.accessTechStatus[j].status +
+                    " restrictCause = " + srvSt.accessTechStatus[j].restrictCause +
+                    " registered = " + srvSt.accessTechStatus[j].registered);
+        }
+    }
+
+    public int getSsNotificationType() {
+        return mSsNotificationType;
+    }
+
+    public int getSsCode() {
+        return mSsCode;
+    }
+
+    public int getSsIndex() {
+        return mSsIndex;
+    }
+
+    public String getSsNumber() {
+        return mSsNumber;
+    }
+
+    private void processSuppSrvNotification(Intent intent) {
+        log("[TEST COMMAND] ACTION_SUPP_SERVICE_NOTIFICATION");
+
+        mSsNotificationType = intent.getIntExtra(EXTRA_SUPP_NOTIFICATION_TYPE, 0);
+        mSsCode = intent.getIntExtra(EXTRA_SUPP_CODE, 0);
+        sendUnsolicitedResponse(ImsQmiIF.UNSOL_SUPP_SVC_NOTIFICATION);
+    }
+
+
+    public void log(String msg) {
+        Log.d(LOG_TAG, msg);
+    }
+
+    private boolean isPhoneNumberString(String number) {
+        if (TextUtils.isEmpty(number)) return false;
+        Pattern p = Pattern.compile("^\\d*$");
+        Matcher m;
+        if (number.startsWith("+")) {
+            m = p.matcher(number.substring("+".length(), number.length()));
+        } else {
+            m = p.matcher(number);
+        }
+        return m.find();
+    }
+
+    private Object responseCallRingback() {
+        int[] response = new int[1];
+        response[0] = (mPlayTone) ? 1 : 0;
+        return response;
+    }
+
+    private void sendRingbackToneResponse(boolean playTone) {
+        if (!RINGBACK_TONE_SUPPORTED) {
+            return;
+        }
+        if (mPlayTone != playTone) {
+            mPlayTone = playTone;
+            sendUnsolicitedResponse(ImsQmiIF.UNSOL_RINGBACK_TONE);
+        }
+    }
+}
-- 
1.7.9.5

